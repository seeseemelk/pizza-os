#ifndef MEMORY_HPP
#define MEMORY_HPP

namespace std
{

//
// Definition of unique_ptr
//

template <class T>
class unique_ptr
{
public:
	// Constructors and destructors
	constexpr unique_ptr() noexcept;
	explicit unique_ptr(T* pointer) noexcept;
	~unique_ptr();

	// Methods
	T* get() const noexcept;
	T* release() noexcept;
	void reset(T* pointer = T()) noexcept;
	void swap(unique_ptr<T>& ptr) noexcept;

	// Operator overloads
	unique_ptr<T>& operator=(unique_ptr<T>&& x) noexcept;
	unique_ptr<T>& operator=(const unique_ptr<T>& x) = delete;

private:
	T* m_pointer;
};

std::unique_ptr<T> make_unique(size_t size)
{
	T* array = new T[size];
	return std::unique_ptr(array);
}

}

//
// Implementation of unique_ptr
//
template <class T>
constexpr std::unique_ptr<T>::unique_ptr()
{
	m_pointer = nullptr;
}

template <class T>
std::unique_ptr<T>::unique_ptr(T* pointer)
{
	m_pointer = pointer;
}

template <class T>
std::unique_ptr<T>::~unique_ptr()
{
	if (m_pointer != nullptr)
		delete m_pointer;
}

template <class T>
T* std::unique_ptr<T>::get() const
{
	return m_pointer;
}

template <class T>
T* std::unique_ptr<T>::release()
{
	T* temp_pointer = m_pointer;
	m_pointer = nullptr;
	return temp_pointer;
}

template <class T>
void std::unique_ptr<T>::reset(T* pointer)
{
	if (m_pointer != nullptr)
		delete m_pointer;
	m_pointer = pointer;
}

template <class T>
std::unique_ptr<T>& std::unique_ptr<T>::operator=(std::unique_ptr<T>&& x)
{
	if (x == nullptr)
		this->reset(nullptr);
	else
		this->reset(x.release());
}

template<class T>
void std::unique_ptr<T>::swap(std::unique_ptr<T>& ptr)
{
	T* temp_pointer = this->m_pointer;
	this->m_pointer = temp_pointer;
	ptr.m_pointer = temp_pointer;
}


#endif














